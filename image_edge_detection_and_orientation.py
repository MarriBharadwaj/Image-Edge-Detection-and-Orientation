# -*- coding: utf-8 -*-
"""Image Edge Detection and Orientation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OpbAbz1sco82V4o2IVWpIefuu_PAZbBI
"""

from PIL import Image, ImageDraw

# Function to create and save an image with a circle
def create_circle_image():
    # Create a blank white image with dimensions 200x200 pixels
    img = Image.new("RGB", (200, 200), "white")
    # Create an object that can be used to draw on the image
    draw = ImageDraw.Draw(img)
    # Draw a blue filled circle with a black outline
    draw.ellipse((50, 50, 150, 150), outline="black", fill="blue")
    # Save the image as 'circle.png'
    img.save("circle.png")

# Function to create and save an image with a square
def create_square_image():
    # Create a blank white image with dimensions 200x200 pixels
    img = Image.new("RGB", (200, 200), "white")
    # Create an object that can be used to draw on the image
    draw = ImageDraw.Draw(img)
    # Draw a red filled square with a black outline
    draw.rectangle((50, 50, 150, 150), outline="black", fill="red")
    # Save the image as 'square.png'
    img.save("square.png")

# Function to create and save an image with a triangle
def create_triangle_image():
    # Create a blank white image with dimensions 200x200 pixels
    img = Image.new("RGB", (200, 200), "white")
    # Create an object that can be used to draw on the image
    draw = ImageDraw.Draw(img)
    # Draw a green filled triangle with a black outline
    draw.polygon([(100, 50), (50, 150), (150, 150)], outline="black", fill="green")
    # Save the image as 'triangle.png'
    img.save("triangle.png")

# Generate the images by calling the functions
create_circle_image()
create_square_image()
create_triangle_image()

# Print a message indicating that the images have been created
print("Images created: circle.png, square.png, triangle.png")

import matplotlib.pyplot as plt
from PIL import Image

# Function to display an image
def display_image(image_path, title):
    # Open the image file using PIL
    img = Image.open(image_path)
    # Display the image using matplotlib
    plt.imshow(img)
    # Set the title of the plot
    plt.title(title)
    # Hide the axes to only show the image
    plt.axis('off')
    # Show the image plot
    plt.show()

# Display the images with their titles
display_image("circle.png", "Circle")
print()  # Print an empty line for spacing
display_image("square.png", "Square")
print()  # Print an empty line for spacing
display_image("triangle.png", "Triangle")

import cv2
import numpy as np

# List of image paths and corresponding descriptions
image_paths = ["circle.png", "square.png", "triangle.png"]
image_descriptions = ["CIRCLE", "SQUARE", "TRIANGLE"]

# Lists to store the original and grayscale images
images = []
grayscale_images = []

# Read and store the images from file paths
for path in image_paths:
    img = cv2.imread(path)
    images.append(img)

# Create a grid of size num_rows x num_cols to display images
num_rows = len(images)
num_cols = 2

# Set up the plot with specified number of rows and columns
fig, axes = plt.subplots(num_rows, num_cols, figsize=(12, 24))

# Process and display each image
for i in range(num_rows):
    # Convert BGR image to RGB for display
    axes[i, 0].imshow(cv2.cvtColor(images[i], cv2.COLOR_BGR2RGB))
    axes[i, 0].set_title(image_descriptions[i])
    axes[i, 0].axis('off')  # Hide axes for the original image

    # Convert the image to grayscale
    grey_img = cv2.cvtColor(images[i], cv2.COLOR_BGR2GRAY)

    # Store the grayscale image in the list
    grayscale_images.append(grey_img)

    # Apply Adaptive Histogram Equalization (AHE) for contrast enhancement
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    enhanced_img = clahe.apply(grey_img)

    # Apply gamma correction for further contrast improvement
    gamma = 1.5  # Adjust gamma value as needed
    enhanced_img_normalised = enhanced_img / 255.0  # normalise the image to [0, 1]
    corrected_img = np.power(enhanced_img_normalised, gamma)  # Apply gamma correction
    corrected_img = np.uint8(corrected_img * 255)  # Convert back to 8-bit image

    # Display the grayscale image with enhancements
    axes[i, 1].imshow(corrected_img, cmap='gray')
    axes[i, 1].set_title("Greyscale - " + image_descriptions[i])
    axes[i, 1].axis('off')  # Hide axes for the grayscale image

# Adjust spacing between subplots for better layout
plt.tight_layout()

# Show the plot with the images
plt.show()

# Select the grayscale image that was determined to be the best (the circle image)
selected_image = grayscale_images[0]

# Apply DoG (Difference of Gaussians) filter for noise removal and contrast improvement
# First Gaussian blur with a smaller sigma
gaussian_blur1 = cv2.GaussianBlur(selected_image, (5, 5), 1)
# Second Gaussian blur with a larger sigma
gaussian_blur2 = cv2.GaussianBlur(selected_image, (5, 5), 2)
# Subtract the two blurred images to enhance edges and remove noise
dog_image = cv2.subtract(gaussian_blur1, gaussian_blur2)

# Display the DoG filtered image
plt.figure(figsize=(6, 6))
plt.imshow(dog_image, cmap='gray')
plt.title("DoG Filtered Image")
plt.axis('off')  # Hide axes
plt.show()

# Design Sobel filters for detecting edges with different orientations
orientations = [0, 45, 90, 135]  # Orientations in degrees
sobel_kernels = []

for orientation in orientations:
    if orientation == 0:
        # Sobel filter for horizontal edges
        kernel = cv2.Sobel(dog_image, cv2.CV_64F, 1, 0, ksize=3)
    elif orientation == 45:
        # Sobel filter for diagonal edges (45 degrees)
        kernel = cv2.Sobel(dog_image, cv2.CV_64F, 1, 1, ksize=3)
    elif orientation == 90:
        # Sobel filter for vertical edges
        kernel = cv2.Sobel(dog_image, cv2.CV_64F, 0, 1, ksize=3)
    elif orientation == 135:
        # Combine Sobel filters for 45-degree and 90-degree to detect edges at 135 degrees
        sobel_45 = cv2.Sobel(dog_image, cv2.CV_64F, 1, 1, ksize=3)
        sobel_90 = cv2.Sobel(dog_image, cv2.CV_64F, 0, 1, ksize=3)
        kernel = cv2.addWeighted(sobel_45, 1, sobel_90, 1, 0)
    sobel_kernels.append(kernel)

# Display the edge images for different orientations
plt.figure(figsize=(12, 12))
for i, kernel in enumerate(sobel_kernels):
    plt.subplot(2, 2, i + 1)
    plt.imshow(kernel, cmap='gray')
    plt.title(f"Edge Detection - {orientations[i]} Degrees")
    plt.axis('off')  # Hide axes

plt.show()

import warnings
warnings.filterwarnings("ignore")  # Ignore warnings to keep the output clean

# Load the selected grayscale image from the list
selected_image = grayscale_images[0]

# Winner-Takes-All (WTA) algorithm: Combine Sobel filter results
wta_image = np.zeros_like(selected_image, dtype=np.float32)  # Initialize an empty image to store WTA results
for filtered_image in sobel_kernels:
    magnitude = np.abs(filtered_image)  # Compute the magnitude of the filtered image
    wta_image = np.maximum(wta_image, magnitude)  # Apply WTA by keeping the maximum magnitude

# Apply Advanced Contrast normalisation (ACN) for normalisation
def acn_normalising(image, wta_image, alpha=0.7, beta=0.3):
    """
    Apply Advanced Contrast normalisation (ACN) to normalise the image.

    Parameters:
    - image: The original image (grayscale).
    - wta_image: The WTA processed image.
    - alpha: Weight for normalisation.
    - beta: Offset for normalisation.

    Returns:
    - normalised_image: The normalised image after applying ACN.
    """
    normalised_image = alpha * (wta_image / image) + beta
    return normalised_image

# normalise the selected image using the ACN function
normalised_image = acn_normalising(selected_image, wta_image, alpha=0.7, beta=0.3)

# Visualise the results
plt.figure(figsize=(12, 6))

# Display the original grayscale image
plt.subplot(1, 3, 1)
plt.imshow(selected_image, cmap='gray')
plt.title("Greyscale Image")
plt.axis('off')

# Display the WTA image
plt.subplot(1, 3, 2)
plt.imshow(wta_image, cmap='gray')
plt.title("WTA Image")
plt.axis('off')

# Display the normalised image
plt.subplot(1, 3, 3)
plt.imshow(normalised_image, cmap='gray')
plt.title("Normalised Image")
plt.axis('off')

# Show all the images in a single figure
plt.show()

# Load the first grayscale image from the list
selected_image = grayscale_images[0]

# Define parameters for filters and thresholds
sigmas = [1.0, 2.0, 3.0]  # Standard deviations for Gaussian blur
ksizes = [3, 5, 7]        # Kernel sizes for Gaussian blur
thresholds = [0.1, 0.2, 0.3]  # Thresholds for WTA image

# Function to apply DoG (Difference of Gaussians) filter
def apply_dog_filter(image, sigma1, sigma2, ksize):
    """
    Apply DoG filter to the image using two Gaussian blurs with different sigma values.

    Parameters:
    - image: The input grayscale image.
    - sigma1: Standard deviation for the first Gaussian blur.
    - sigma2: Standard deviation for the second Gaussian blur.
    - ksize: Kernel size for Gaussian blurs.

    Returns:
    - dog: The image after applying the DoG filter.
    """
    gauss1 = cv2.GaussianBlur(image, (ksize, ksize), sigma1)
    gauss2 = cv2.GaussianBlur(image, (ksize, ksize), sigma2)
    dog = gauss1 - gauss2
    return dog

# Function to apply Sobel edge detection
def apply_edge_detection(image, ksize):
    """
    Apply Sobel edge detection to the image with different orientations.

    Parameters:
    - image: The input grayscale image.
    - ksize: Kernel size for Sobel filters.

    Returns:
    - sobel_kernels: List of edge-detected images for different orientations.
    """
    orientations = [0, 45, 90, 135]  # Different orientations for edge detection
    sobel_kernels = []

    for orientation in orientations:
        if orientation == 0:
            kernel = cv2.Sobel(image, cv2.CV_64F, 1, 0, ksize=ksize)
        elif orientation == 45:
            kernel = cv2.Sobel(image, cv2.CV_64F, 1, 1, ksize=ksize)
        elif orientation == 90:
            kernel = cv2.Sobel(image, cv2.CV_64F, 0, 1, ksize=ksize)
        elif orientation == 135:
            sobel_45 = cv2.Sobel(image, cv2.CV_64F, 1, 1, ksize=ksize)
            sobel_90 = cv2.Sobel(image, cv2.CV_64F, 0, 1, ksize=ksize)
            kernel = cv2.addWeighted(sobel_45, 1, sobel_90, 1, 0)
        sobel_kernels.append(kernel)
    return sobel_kernels

# Function to apply Winner-Takes-All (WTA) and normalisation
def apply_wta_and_normalisation(image, edge_images, threshold):
    """
    Apply Winner-Takes-All (WTA) and Advanced Contrast normalisation (ACN) to the image.

    Parameters:
    - image: The input grayscale image.
    - edge_images: List of edge-detected images.
    - threshold: Threshold for WTA image.

    Returns:
    - wta_image: The WTA processed image.
    - normalised_image: The normalised image after applying ACN.
    """
    # Apply Winner-Takes-All
    wta_image = np.zeros_like(image, dtype=np.float32)
    for edge_image in edge_images:
        magnitude = np.abs(edge_image)
        wta_image = np.maximum(wta_image, magnitude)

    # Apply threshold
    wta_image[wta_image < threshold] = 0

    # Apply Advanced Contrast normalisation (ACN)
    def acn_normalising(image, wta_image, alpha=0.7, beta=0.3):
        normalised_image = alpha * (wta_image / (image + 1e-6)) + beta
        return normalised_image

    normalised_image = acn_normalising(image, wta_image, alpha=0.7, beta=0.3)

    return wta_image, normalised_image

# Iterate through parameter combinations to find the best result
best_result = None
best_params = None
best_normalised_image = None

for sigma1 in sigmas:
    for sigma2 in sigmas:
        for ksize in ksizes:
            for threshold in thresholds:
                if sigma1 >= sigma2:
                    continue  # Ensure sigma1 > sigma2 for valid DoG filter

                # Apply DoG filter
                dog_image = apply_dog_filter(selected_image, sigma1, sigma2, ksize)

                # Apply edge detection
                edge_images = apply_edge_detection(dog_image, ksize)

                # Apply WTA and normalisation
                wta_image, normalised_image = apply_wta_and_normalisation(dog_image, edge_images, threshold)

                # Display results for the current set of parameters
                plt.figure(figsize=(20, 10))

                plt.subplot(1, 4, 1)
                plt.imshow(selected_image, cmap='gray')
                plt.title("Greyscale Image")
                plt.axis('off')

                plt.subplot(1, 4, 2)
                plt.imshow(dog_image, cmap='gray')
                plt.title(f"DoG (σ1={sigma1}, σ2={sigma2}, ksize={ksize})")
                plt.axis('off')

                plt.subplot(1, 4, 3)
                plt.imshow(wta_image, cmap='gray')
                plt.title(f"WTA (Threshold={threshold})")
                plt.axis('off')

                plt.subplot(1, 4, 4)
                plt.imshow(normalised_image, cmap='gray')
                plt.title(f"normalised (Threshold={threshold})")
                plt.axis('off')

                plt.show()

                # Update the best result if necessary
                if best_result is None or np.sum(normalised_image) > np.sum(best_normalised_image):
                    best_result = {
                        'sigma1': sigma1,
                        'sigma2': sigma2,
                        'ksize': ksize,
                        'threshold': threshold
                    }
                    best_normalised_image = normalised_image
                    best_wta_image = wta_image  # Save the best WTA image

# Display the best result
plt.figure(figsize=(12, 6))

plt.subplot(1, 3, 1)
plt.imshow(selected_image, cmap='gray')
plt.title("Greyscale Image")
plt.axis('off')

plt.subplot(1, 3, 2)
plt.imshow(best_wta_image, cmap='gray')
plt.title(f"Best WTA (σ1={best_result['sigma1']}, σ2={best_result['sigma2']}, ksize={best_result['ksize']}, Threshold={best_result['threshold']})")
plt.axis('off')

plt.subplot(1, 3, 3)
plt.imshow(best_normalised_image, cmap='gray')
plt.title("Best Normalised Image")
plt.axis('off')

plt.show()

print(f"Best Parameters: {best_result}")

"""SQUARE"""

selected_image = grayscale_images[1]

# Apply DoG (Difference of Gaussians) filter for noise removal and contrast improvement
# First Gaussian blur with a smaller sigma
gaussian_blur1 = cv2.GaussianBlur(selected_image, (5, 5), 1)
# Second Gaussian blur with a larger sigma
gaussian_blur2 = cv2.GaussianBlur(selected_image, (5, 5), 2)
# Subtract the two blurred images to enhance edges and remove noise
dog_image = cv2.subtract(gaussian_blur1, gaussian_blur2)

# Display the DoG filtered image
plt.figure(figsize=(6, 6))
plt.imshow(dog_image, cmap='gray')
plt.title("DoG Filtered Image")
plt.axis('off')  # Hide axes
plt.show()

# Design Sobel filters for detecting edges with different orientations
# Orientations in degrees
sobel_kernels = []

for orientation in orientations:
    if orientation == 0:
        # Sobel filter for horizontal edges
        kernel = cv2.Sobel(dog_image, cv2.CV_64F, 1, 0, ksize=3)
    elif orientation == 45:
        # Sobel filter for diagonal edges (45 degrees)
        kernel = cv2.Sobel(dog_image, cv2.CV_64F, 1, 1, ksize=3)
    elif orientation == 90:
        # Sobel filter for vertical edges
        kernel = cv2.Sobel(dog_image, cv2.CV_64F, 0, 1, ksize=3)
    elif orientation == 135:
        # Combine Sobel filters for 45-degree and 90-degree to detect edges at 135 degrees
        sobel_45 = cv2.Sobel(dog_image, cv2.CV_64F, 1, 1, ksize=3)
        sobel_90 = cv2.Sobel(dog_image, cv2.CV_64F, 0, 1, ksize=3)
        kernel = cv2.addWeighted(sobel_45, 1, sobel_90, 1, 0)
    sobel_kernels.append(kernel)

# Display the edge images for different orientations
plt.figure(figsize=(12, 12))
for i, kernel in enumerate(sobel_kernels):
    plt.subplot(2, 2, i + 1)
    plt.imshow(kernel, cmap='gray')
    plt.title(f"Edge Detection - {orientations[i]} Degrees")
    plt.axis('off')  # Hide axes

plt.show()

# Winner-Takes-All (WTA) algorithm: Combine Sobel filter results
wta_image = np.zeros_like(selected_image, dtype=np.float32)  # Initialize an empty image to store WTA results
for filtered_image in sobel_kernels:
    magnitude = np.abs(filtered_image)  # Compute the magnitude of the filtered image
    wta_image = np.maximum(wta_image, magnitude)  # Apply WTA by keeping the maximum magnitude

# Apply Advanced Contrast normalisation (ACN) for normalisation
# normalise the selected image using the ACN function
normalised_image = acn_normalising(selected_image, wta_image, alpha=0.7, beta=0.3)

# Visualise the results
plt.figure(figsize=(12, 6))

# Display the original grayscale image
plt.subplot(1, 3, 1)
plt.imshow(selected_image, cmap='gray')
plt.title("Greyscale Image")
plt.axis('off')

# Display the WTA image
plt.subplot(1, 3, 2)
plt.imshow(wta_image, cmap='gray')
plt.title("WTA Image")
plt.axis('off')

# Display the normalised image
plt.subplot(1, 3, 3)
plt.imshow(normalised_image, cmap='gray')
plt.title("Normalised Image")
plt.axis('off')

# Show all the images in a single figure
plt.show()

# Iterate through parameter combinations to find the best result
best_result = None
best_params = None
best_normalised_image = None

for sigma1 in sigmas:
    for sigma2 in sigmas:
        for ksize in ksizes:
            for threshold in thresholds:
                if sigma1 >= sigma2:
                    continue  # Ensure sigma1 > sigma2 for valid DoG filter

                # Apply DoG filter
                dog_image = apply_dog_filter(selected_image, sigma1, sigma2, ksize)

                # Apply edge detection
                edge_images = apply_edge_detection(dog_image, ksize)

                # Apply WTA and normalisation
                wta_image, normalised_image = apply_wta_and_normalisation(dog_image, edge_images, threshold)

                # Display results for the current set of parameters
                plt.figure(figsize=(20, 10))

                plt.subplot(1, 4, 1)
                plt.imshow(selected_image, cmap='gray')
                plt.title("Greyscale Image")
                plt.axis('off')

                plt.subplot(1, 4, 2)
                plt.imshow(dog_image, cmap='gray')
                plt.title(f"DoG (σ1={sigma1}, σ2={sigma2}, ksize={ksize})")
                plt.axis('off')

                plt.subplot(1, 4, 3)
                plt.imshow(wta_image, cmap='gray')
                plt.title(f"WTA (Threshold={threshold})")
                plt.axis('off')

                plt.subplot(1, 4, 4)
                plt.imshow(normalised_image, cmap='gray')
                plt.title(f"normalised (Threshold={threshold})")
                plt.axis('off')

                plt.show()

                # Update the best result if necessary
                if best_result is None or np.sum(normalised_image) > np.sum(best_normalised_image):
                    best_result = {
                        'sigma1': sigma1,
                        'sigma2': sigma2,
                        'ksize': ksize,
                        'threshold': threshold
                    }
                    best_normalised_image = normalised_image
                    best_wta_image = wta_image  # Save the best WTA image

# Display the best result
plt.figure(figsize=(12, 6))

plt.subplot(1, 3, 1)
plt.imshow(selected_image, cmap='gray')
plt.title("Greyscale Image")
plt.axis('off')

plt.subplot(1, 3, 2)
plt.imshow(best_wta_image, cmap='gray')
plt.title(f"Best WTA (σ1={best_result['sigma1']}, σ2={best_result['sigma2']}, ksize={best_result['ksize']}, Threshold={best_result['threshold']})")
plt.axis('off')

plt.subplot(1, 3, 3)
plt.imshow(best_normalised_image, cmap='gray')
plt.title("Best Normalised Image")
plt.axis('off')

plt.show()

print(f"Best Parameters: {best_result}")

"""TRIANGLE"""

selected_image = grayscale_images[2]

# Apply DoG (Difference of Gaussians) filter for noise removal and contrast improvement
# First Gaussian blur with a smaller sigma
gaussian_blur1 = cv2.GaussianBlur(selected_image, (5, 5), 1)
# Second Gaussian blur with a larger sigma
gaussian_blur2 = cv2.GaussianBlur(selected_image, (5, 5), 2)
# Subtract the two blurred images to enhance edges and remove noise
dog_image = cv2.subtract(gaussian_blur1, gaussian_blur2)

# Display the DoG filtered image
plt.figure(figsize=(6, 6))
plt.imshow(dog_image, cmap='gray')
plt.title("DoG Filtered Image")
plt.axis('off')  # Hide axes
plt.show()

# Design Sobel filters for detecting edges with different orientations
# Orientations in degrees
sobel_kernels = []

for orientation in orientations:
    if orientation == 0:
        # Sobel filter for horizontal edges
        kernel = cv2.Sobel(dog_image, cv2.CV_64F, 1, 0, ksize=3)
    elif orientation == 45:
        # Sobel filter for diagonal edges (45 degrees)
        kernel = cv2.Sobel(dog_image, cv2.CV_64F, 1, 1, ksize=3)
    elif orientation == 90:
        # Sobel filter for vertical edges
        kernel = cv2.Sobel(dog_image, cv2.CV_64F, 0, 1, ksize=3)
    elif orientation == 135:
        # Combine Sobel filters for 45-degree and 90-degree to detect edges at 135 degrees
        sobel_45 = cv2.Sobel(dog_image, cv2.CV_64F, 1, 1, ksize=3)
        sobel_90 = cv2.Sobel(dog_image, cv2.CV_64F, 0, 1, ksize=3)
        kernel = cv2.addWeighted(sobel_45, 1, sobel_90, 1, 0)
    sobel_kernels.append(kernel)

# Display the edge images for different orientations
plt.figure(figsize=(12, 12))
for i, kernel in enumerate(sobel_kernels):
    plt.subplot(2, 2, i + 1)
    plt.imshow(kernel, cmap='gray')
    plt.title(f"Edge Detection - {orientations[i]} Degrees")
    plt.axis('off')  # Hide axes

plt.show()

# Winner-Takes-All (WTA) algorithm: Combine Sobel filter results
wta_image = np.zeros_like(selected_image, dtype=np.float32)  # Initialize an empty image to store WTA results
for filtered_image in sobel_kernels:
    magnitude = np.abs(filtered_image)  # Compute the magnitude of the filtered image
    wta_image = np.maximum(wta_image, magnitude)  # Apply WTA by keeping the maximum magnitude

# Apply Advanced Contrast normalisation (ACN) for normalisation
# normalise the selected image using the ACN function
normalised_image = acn_normalising(selected_image, wta_image, alpha=0.7, beta=0.3)

# Visualise the results
plt.figure(figsize=(12, 6))

# Display the original grayscale image
plt.subplot(1, 3, 1)
plt.imshow(selected_image, cmap='gray')
plt.title("Greyscale Image")
plt.axis('off')

# Display the WTA image
plt.subplot(1, 3, 2)
plt.imshow(wta_image, cmap='gray')
plt.title("WTA Image")
plt.axis('off')

# Display the normalised image
plt.subplot(1, 3, 3)
plt.imshow(normalised_image, cmap='gray')
plt.title("Normalised Image")
plt.axis('off')

# Show all the images in a single figure
plt.show()

# Iterate through parameter combinations to find the best result
best_result = None
best_params = None
best_normalised_image = None

for sigma1 in sigmas:
    for sigma2 in sigmas:
        for ksize in ksizes:
            for threshold in thresholds:
                if sigma1 >= sigma2:
                    continue  # Ensure sigma1 > sigma2 for valid DoG filter

                # Apply DoG filter
                dog_image = apply_dog_filter(selected_image, sigma1, sigma2, ksize)

                # Apply edge detection
                edge_images = apply_edge_detection(dog_image, ksize)

                # Apply WTA and normalisation
                wta_image, normalised_image = apply_wta_and_normalisation(dog_image, edge_images, threshold)

                # Display results for the current set of parameters
                plt.figure(figsize=(20, 10))

                plt.subplot(1, 4, 1)
                plt.imshow(selected_image, cmap='gray')
                plt.title("Greyscale Image")
                plt.axis('off')

                plt.subplot(1, 4, 2)
                plt.imshow(dog_image, cmap='gray')
                plt.title(f"DoG (σ1={sigma1}, σ2={sigma2}, ksize={ksize})")
                plt.axis('off')

                plt.subplot(1, 4, 3)
                plt.imshow(wta_image, cmap='gray')
                plt.title(f"WTA (Threshold={threshold})")
                plt.axis('off')

                plt.subplot(1, 4, 4)
                plt.imshow(normalised_image, cmap='gray')
                plt.title(f"normalised (Threshold={threshold})")
                plt.axis('off')

                plt.show()

                # Update the best result if necessary
                if best_result is None or np.sum(normalised_image) > np.sum(best_normalised_image):
                    best_result = {
                        'sigma1': sigma1,
                        'sigma2': sigma2,
                        'ksize': ksize,
                        'threshold': threshold
                    }
                    best_normalised_image = normalised_image
                    best_wta_image = wta_image  # Save the best WTA image

# Display the best result
plt.figure(figsize=(12, 6))

plt.subplot(1, 3, 1)
plt.imshow(selected_image, cmap='gray')
plt.title("Greyscale Image")
plt.axis('off')

plt.subplot(1, 3, 2)
plt.imshow(best_wta_image, cmap='gray')
plt.title(f"Best WTA (σ1={best_result['sigma1']}, σ2={best_result['sigma2']}, ksize={best_result['ksize']}, Threshold={best_result['threshold']})")
plt.axis('off')

plt.subplot(1, 3, 3)
plt.imshow(best_normalised_image, cmap='gray')
plt.title("Best Normalised Image")
plt.axis('off')

plt.show()

print(f"Best Parameters: {best_result}")

from google.colab import drive
drive.mount('/content/drive')

# Replace with your image path
image_path = '/content/drive/MyDrive/PBV_Assignment1/05-ruins.jpg'
print(image_path)
image = cv2.imread(image_path)

img_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Display the original image
plt.imshow(img_rgb)
plt.title('Original Image')
plt.show()

grey_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

plt.imshow(grey_image, cmap='gray')
plt.title('Greyscale Image')
plt.show()

# Apply DoG filter (Difference of Gaussians) for noise removal and contrast improvement
gaussian_blur1 = cv2.GaussianBlur(grey_image, (5, 5), 1)
gaussian_blur2 = cv2.GaussianBlur(grey_image, (5, 5), 2)
dog_image = cv2.subtract(gaussian_blur1, gaussian_blur2)

# Display the DoG filtered image
plt.figure(figsize=(6, 6))
plt.imshow(dog_image, cmap='gray')
plt.title("DoG Filtered Image")
plt.axis('off')
plt.show()

# Design Sobel filters for detecting edges with different orientations
sobel_kernels = []

for orientation in orientations:
    if orientation == 0:
        kernel = cv2.Sobel(dog_image, cv2.CV_64F, 1, 0, ksize=3)
    elif orientation == 45:
        kernel = cv2.Sobel(dog_image, cv2.CV_64F, 1, 1, ksize=3)
    elif orientation == 90:
        kernel = cv2.Sobel(dog_image, cv2.CV_64F, 0, 1, ksize=3)
    elif orientation == 135:
        # Combining Sobel 45-degree and 90-degree filters to simulate 135-degree edges
        sobel_45 = cv2.Sobel(dog_image, cv2.CV_64F, 1, 1, ksize=3)
        sobel_90 = cv2.Sobel(dog_image, cv2.CV_64F, 0, 1, ksize=3)
        kernel = cv2.addWeighted(sobel_45, 1, sobel_90, 1, 0)
    sobel_kernels.append(kernel)

# Display the edge images for different orientations
plt.figure(figsize=(12, 12))
for i, kernel in enumerate(sobel_kernels):
    plt.subplot(2, 2, i + 1)
    plt.imshow(kernel, cmap='gray')
    plt.title(f"Edge Detection - {orientations[i]} Degrees")
    plt.axis('off')

plt.show()

# Load the selected image in grayscale
selected_image = grey_image
# Winner-Takes-All (WTA) algorithm
wta_image = np.zeros_like(selected_image,dtype=np.float32)
for filtered_image in sobel_kernels:
    magnitude = np.abs(filtered_image)
    wta_image = np.maximum(wta_image, magnitude)

# # Apply Advanced Contrast normalisation (ACN) for normalisation
normalised_image = acn_normalising(selected_image, wta_image,alpha=0.7, beta=0.3)
# Step 5: Visualise the WTA and normalised images
plt.figure(figsize=(12, 6))

plt.subplot(1, 3, 1)
plt.imshow(selected_image, cmap='gray')
plt.title("Greyscale Image")
plt.axis('off')

plt.subplot(1, 3, 2)
plt.imshow(wta_image, cmap='gray')
plt.title("WTA Image")
plt.axis('off')

plt.subplot(1, 3, 3)
plt.imshow(normalised_image, cmap='gray')
plt.title("Normalised Image")
plt.axis('off')

plt.show()

# Define parameters
sigmas = [0.5, 1.0, 1.5, 2.0, 2.5, 3.0]
ksizes = [3, 5, 7]
thresholds = [0.1, 0.2, 0.5, 1, 2]  # Example thresholds

# Iterate through parameter combinations
best_result = None
best_params = None
best_normalised_image = None

for sigma1 in sigmas:
    for sigma2 in sigmas:
        for ksize in ksizes:
            for threshold in thresholds:
                if sigma1 >= sigma2:
                    continue  # Ensure sigma1 > sigma2 for valid DoG filter

                # Apply DoG filter
                dog_image = apply_dog_filter(selected_image, sigma1, sigma2, ksize)

                # Apply edge detection
                edge_images = apply_edge_detection(dog_image, ksize)

                # Apply WTA and normalisation
                wta_image, normalised_image = apply_wta_and_normalisation(dog_image, edge_images, threshold)

                # Can't display respective image for each set of parameter during tuning since it would require too much RAM

                # Update the best result if necessary
                if best_result is None or np.sum(normalised_image) > np.sum(best_normalised_image):
                    best_result = {
                        'sigma1': sigma1,
                        'sigma2': sigma2,
                        'ksize': ksize,
                        'threshold': threshold
                    }
                    best_normalised_image = normalised_image
                    best_wta_image = wta_image  # Save the best WTA image

# Display the best result
plt.figure(figsize=(12, 6))

plt.subplot(1, 3, 1)
plt.imshow(selected_image, cmap='gray')
plt.title("Greyscale Image")
plt.axis('off')

plt.subplot(1, 3, 2)
plt.imshow(best_wta_image, cmap='gray')
plt.title(f"Best WTA (σ1={best_result['sigma1']}, σ2={best_result['sigma2']}, ksize={best_result['ksize']}, Threshold={best_result['threshold']})")
plt.axis('off')

plt.subplot(1, 3, 3)
plt.imshow(best_normalised_image, cmap='gray')
plt.title("Best Normalised Image")
plt.axis('off')

plt.show()

print(f"Best Parameters: {best_result}")

"""Displaying images for some set of parameters to observe the gradual variation"""

# Define parameters for filters and thresholds
sigmas = [0.5, 1.0, 1.5, 2.0, 2.5]
ksizes = [3, 5, 7]        # Kernel sizes for Gaussian blur
thresholds = [0.1, 0.2, 0.3]  # Thresholds for WTA image
for sigma1 in sigmas:
    for sigma2 in sigmas:
        for ksize in ksizes:
            for threshold in thresholds:
                if sigma1 >= sigma2:
                    continue  # Ensure sigma1 > sigma2 for valid DoG filter

                # Apply DoG filter
                dog_image = apply_dog_filter(selected_image, sigma1, sigma2, ksize)

                # Apply edge detection
                edge_images = apply_edge_detection(dog_image, ksize)

                # Apply WTA and normalisation
                wta_image, normalised_image = apply_wta_and_normalisation(dog_image, edge_images, threshold)

                # Display results for the current set of parameters
                plt.figure(figsize=(20, 10))

                plt.subplot(1, 4, 1)
                plt.imshow(selected_image, cmap='gray')
                plt.title("Greyscale Image")
                plt.axis('off')

                plt.subplot(1, 4, 2)
                plt.imshow(dog_image, cmap='gray')
                plt.title(f"DoG (σ1={sigma1}, σ2={sigma2}, ksize={ksize})")
                plt.axis('off')

                plt.subplot(1, 4, 3)
                plt.imshow(wta_image, cmap='gray')
                plt.title(f"WTA (Threshold={threshold})")
                plt.axis('off')

                plt.subplot(1, 4, 4)
                plt.imshow(normalised_image, cmap='gray')
                plt.title(f"normalised (Threshold={threshold})")
                plt.axis('off')

                plt.show()

# Can't display more combinations (such as for eg. sigma = 3.0) for parameters due to insufficient RAM

"""## Sample Testing for Colour Image"""

# Apply DoG filter (Difference of Gaussians) for noise removal and contrast improvement
gaussian_blur1 = cv2.GaussianBlur(img_rgb, (5, 5), 1)
gaussian_blur2 = cv2.GaussianBlur(img_rgb, (5, 5), 2)
dog_image = cv2.subtract(gaussian_blur1, gaussian_blur2)

# Display the DoG filtered image
plt.figure(figsize=(6, 6))
plt.imshow(dog_image, cmap='gray')
plt.title("DoG Filtered Image")
plt.axis('off')
plt.show()

# Design Sobel filters for detecting edges with different orientations
sobel_kernels = []

for orientation in orientations:
    if orientation == 0:
        kernel = cv2.Sobel(dog_image, cv2.CV_64F, 1, 0, ksize=3)
    elif orientation == 45:
        kernel = cv2.Sobel(dog_image, cv2.CV_64F, 1, 1, ksize=3)
    elif orientation == 90:
        kernel = cv2.Sobel(dog_image, cv2.CV_64F, 0, 1, ksize=3)
    elif orientation == 135:
        # Combining Sobel 45-degree and 90-degree filters to simulate 135-degree edges
        sobel_45 = cv2.Sobel(dog_image, cv2.CV_64F, 1, 1, ksize=3)
        sobel_90 = cv2.Sobel(dog_image, cv2.CV_64F, 0, 1, ksize=3)
        kernel = cv2.addWeighted(sobel_45, 1, sobel_90, 1, 0)
    sobel_kernels.append(kernel)

# Display the edge images for different orientations
plt.figure(figsize=(12, 12))
for i, kernel in enumerate(sobel_kernels):
    plt.subplot(2, 2, i + 1)
    plt.imshow(kernel, cmap='gray')
    plt.title(f"Edge Detection - {orientations[i]} Degrees")
    plt.axis('off')

plt.show()

# Load the selected image in RGB
selected_image = img_rgb
# Winner-Takes-All (WTA) algorithm
wta_image = np.zeros_like(selected_image,dtype=np.float32)
for filtered_image in sobel_kernels:
    magnitude = np.abs(filtered_image)
    wta_image = np.maximum(wta_image, magnitude)

# # Apply Advanced Contrast normalisation (ACN) for normalisation
normalised_image = acn_normalising(selected_image, wta_image,alpha=0.7, beta=0.3)
# Step 5: Visualise the WTA and normalised images
plt.figure(figsize=(12, 6))

plt.subplot(1, 3, 1)
plt.imshow(selected_image, cmap='gray')
plt.title("Original Image")
plt.axis('off')

plt.subplot(1, 3, 2)
plt.imshow(wta_image, cmap='gray')
plt.title("WTA Image")
plt.axis('off')

plt.subplot(1, 3, 3)
plt.imshow(normalised_image, cmap='gray')
plt.title("Normalised Image")
plt.axis('off')

plt.show()